The below code is implementation of a distributed file system. The system consists of a master metadata server (rank 0) and multiple storage servers (ranks 1 to N-1).

Now you need to implement the following features in the system:
1. Failover rank : Stops requests and heartbeat signals for a specific node rank.
2. Recover rank : Restores the ability of a node to serve requests and resume heartbeat signals.

Heartbeat Mechanism
• Each node sends a periodic heartbeat to the metadata server.
• If a node fails to send a heartbeat, it is marked as down.
• Keep the failover interval to be 3 seconds, i.e., if the metadata server does not receive a heartbeat from a node for more than 3 seconds, it will mark that node as down.
• This can be done by using a separate thread for handling heartbeats. 

Examples:

# Input

1. failover rank: Simulate the failure of a storage server node by specifying its rank. This stops the node from sending heartbeats and processing requests. 

Example:

failover 3 

rank 0 process communicates with rank 3 process that it has to stop sending heartbeat  Then process with rank 3 stops its heartbeat to process 0 , then process 0 detects that it has not recieved a heartbeat in the last HEARTBEAT_INTERVAL seconds , then it labels node with rank 3 as down


2.recover rank: Recover a previously failed storage server node by specifying its rank. This restores the node’s ability to send heartbeats and process requests.

Example:

recover 3

rank 0 process communicates with rank 3 process that it has to start sending heartbeat  Then process with rank 3 starts its heartbeat to process 0 , then process 0 detects that it has recieved a heartbeat in the last HEARTBEAT_INTERVAL seconds , then it labels node with rank 3 as up

Make sure to handle and check heartbeats from all storage nodes to the metadataserver and track their time of last heartbeat. If a node does not send a heartbeat for more than 3 seconds, it should be marked as down.

Make sure to handle threads properly without segmentation faults

Make sure to track and update timestamps for heartbeats properly

Extend the code and output relevant changes in the below code snippet required to implement the above features. Make sure that you have handled all the required feature implementations in the code

#include <mpi.h>
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <algorithm>
#include <map>
#include <sstream>
#include <set>
#define CHUNK_SIZE 32
#define REPLICATION_FACTOR 3
#define UPLOAD_TAG 1
#define RETRIEVE_TAG 2
#define SEARCH_TAG 3
#define FAILOVER_TAG 4
#define RECOVER_TAG 5
#define EXIT_TAG 6
#define HEARTBEAT_TAG 7

using namespace std;


MPI_Datatype MPI_BODY;

struct Compare
{
    bool operator()(const pair<int, int> &a, const pair<int, int> &b) const
    {
        return a.first < b.first || (a.first == b.first && a.second < b.second);
    }
};

using namespace std;

struct ChunkMetaData
{
    int chunk_id;
    vector<int> replica_node_ranks;
};

struct FileMetaData
{
    string file_name;
    vector<ChunkMetaData> chunks;
    vector<int> offsets;
};

struct Body
{
    int request_type;
    int chunk_id;
    int sender_rank;
    bool stop;
};

struct Chunk
{
    int chunk_id;
    string data;
};

int main(int argc, char **argv)
{
    int size, rank;
    MPI_Init(&argc, &argv);
    MPI_Comm_size(MPI_COMM_WORLD, &size);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    int blocklength = sizeof(Body);
    MPI_Type_contiguous(blocklength, MPI_BYTE, &MPI_BODY);
    MPI_Type_commit(&MPI_BODY);
    if (rank == 0)
    {
        // Master Metadata Server
        map<string, FileMetaData> files;
        multiset<pair<int, int>, Compare> chunk_size_set;
        for (int i = 1; i < size; i++)
        {
            chunk_size_set.insert({0, i});
        }
        int N = size;
        string command;
        set<int> failed_nodes;
        std::filesystem::path cpp_file_path(__FILE__);
        std::filesystem::path cpp_directory = cpp_file_path.parent_path();

        while (getline(cin, command))
        {
            stringstream ss(command);
            ss >> command;
            if (command == "upload")
            {
                // Assume that this feature is implemented
            }
            else if (command == "list_file")
            {
                // Assume that this feature is implemented
            }
            else if (command == "retrieve")
            {
                // Assume that this feature is implemented
            }
            else if (command == "search")
            {
                // Assume that this feature is implemented
            }
            else if (command == "failover")
            {
                int failover_rank;
                ss >> failover_rank;
                failed_nodes.insert(failover_rank);
                cout << 1 << endl;
                auto it = std::find_if(chunk_size_set.begin(), chunk_size_set.end(), [failover_rank](const std::pair<int, int> &p)
                           { return p.second == failover_rank; });
                if (it != chunk_size_set.end())
                {
                    std::pair<int, int> updated = *it; 
                    chunk_size_set.erase(it);         
                    updated.first = 0;               
                    chunk_size_set.insert(updated);   
                }
            }
            else if (command == "recover")
            {
                int recover_rank;
                ss >> recover_rank;
                failed_nodes.erase(recover_rank);
                cout << 1 << endl;
            }
            else if (command == "exit")
            {
                for (int i = 1; i < size; i++)
                {
                    Body body;
                    MPI_Send(&body, 1, MPI_BODY, i, EXIT_TAG, MPI_COMM_WORLD);
                }
                break;
            }
        }
    }
    else
    {
        map<string, vector<Chunk>> storage;
        while (true)
        {
            Body body;
            MPI_Status status;
            MPI_Recv(&body, 1, MPI_BODY, 0, MPI_ANY_TAG, MPI_COMM_WORLD, &status);
            if (status.MPI_TAG == UPLOAD_TAG)
            {
                // Assume that this feature is implemented
            }
            else if (status.MPI_TAG == RETRIEVE_TAG)
            {
                // Assume that this feature is implemented
            }
            else if (status.MPI_TAG == SEARCH_TAG)
            {
                // Assume that this feature is implemented
            }
            else if (status.MPI_TAG == FAILOVER_TAG)
            {
                
            }
            else if (status.MPI_TAG == RECOVER_TAG)
            {
                
            }
            else if (status.MPI_TAG == EXIT_TAG)
            {
                break;
            }
        }
    }
    MPI_Finalize();
    return 0;
}